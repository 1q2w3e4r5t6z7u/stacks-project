IMPORTANT
---------

Before hacking away and spending enormous amounts of time on a project for
the stacks project, choose a smaller task, say something you can do in 5
minutes up to an hour. Email the result (usually the modified tex file) to

	stacks.project@gmail.com

and see what it feels like to donate some of your own work to a publicly
maintained project. Having done this successfully you can try your hand at some
more ambitious projects.

Also, it is very helpful if you try to keep to the coding style which is used
throughout the tex files.


TASKS YOU CAN DO WHILE HAVING A BEER
------------------------------------

(1) Run any of the tex files through a spell checker and correct any errors.
(2) Find incompatible notation and correct it. The same mathematical object
should be coded in the same way everywhere.
(3) Read a random section and find small mathematical errors, such as arrows
pointing the wrong way, wrong font, sign errors, etc. If they are small enough
you can simply correct them. Otherwise, just email what's wrong.
(4) Provide counter examples for silly statements. For example, find a
Noetherian ring which is not of finite type over a field, namely Z. (Just
to give you an idea.)
(5) Basic notions. Write something basic about algebra, topology, fields, etc
which goes in an early part (and hasn't been written yet).
(6) Find ocurrences of \coprod and \amalg and consistently have the following
	A \amalg B
	\coprod_{i\in I} A_i
	A \amalg \coprod_{i\in I} B_i
i.e., use \amalg if there are only two and \coprod if there are more. The last
one doesn't look good, but \coprod \coprod_i is even worse!


TASKS YOU CAN DO WHILE HAVING TEA
---------------------------------

(1) Provide missing proofs of easy statements which have been omitted. To find
these do a case insensitive search for the string ``omit'' in the text. If you
hit on a omitted proof which you find too hard, then please report this.
(2) Check for missing internal references. Generally speaking the goal is to
refer to all of the previous lemmas/propositions/theorems used in a proof. Go
through some of the proofs and check if previous results are used without
referencing them.
(3) Find mathematical mistakes.
(4) Find superfluous assumptions.
(5) Find missing assumptions.
(6) Specific example of (2): Find all places where it is used that an etale
morphism of schemes is locally quasi-finite and put in a reference to
Lemma lemma-etale-locally-quasi-finite.


TASKS YOU CAN DO WHILE HAVING COFFEE
------------------------------------

(1) Split longer proofs into pieces by finding intermediate results.
(2) Find alternative proofs (but beware of creating circular arguments).
(3) Write introductions, overviews of already existing material.
(4) Add sections on your favorite topic. For example: You may be interested in
curves. Then in the chapter ``Varieties'' you can start write a section
entitled ``Curves''. For example you can provide a theorem saying that the
category of curves (with dominant rational maps) over a field k is equivalent
to the category of finitely generated field extensions of transcendence degree
1 over k.
(5) Should we change etale into \'etale everywhere?
(6) Change terminology: radicial --> universally injective, and introduce a
separate notion ``radicial which talks about field extensions in points being
purely inseparable.
(7) ``opp'' ---> ``op'' for opposite category?


MORE DIFFICULT TASKS
--------------------

(1) Finally start adding material on algebraic stacks.
(2) Algebraic Spaces: It might be useful to list all the properties P such
that: f has P => \Delta_f has P. Then if f is stable under base change, then
gf and g has P => f has P. Notable exceptions are quasi-compact and finite
type and this explains the relevance of qcqs and finite presentation.
(3) Morphisms of Schemes: Unramified morphisms. Change the definition of
unramified to only require locally of finite *type* (not presentation). This
is used by Raynaud in "Anneaux locaux hensÃ©liens" (1970), by Laumon,
Moret-Baillet and others. Some natural results hold in this generality:
	if f : X -> Y is locally of finite type then:
		f unramified <=>
		\Delta_f open <=>
		fibers of f are separable
	and
		unramifed at x => unramified in a neighborhood of x
The reason is that locally of finite type implies that the diagonal is locally
of finite presentation so unramified <=> diagonal is open immersion and so on.
Compare with other notions such as quasi-finite and proper for which it is
natural to allow finite type morphisms. How to proceed:
	(3)(a) Introduce the corresponding commutative algebra notion (finite
	type and \Omega_{S/R} = 0), and call it ``R-unramified'' in the
	commutative algebra chapter.
	(3)(b) Prove ``R-'' versions of the available algebra results.
	(3)(c) In the chapter on morphisms, introduce ``R-unramified''
	morphisms.
	(3)(d) Prove ``R-'' versions of the available results on morphisms.
	...
	(3)(z) Do a search and replace: ``unramified --> EGA-unramified'', and
	``R-unramified --> unramified''.
The importance of proceeding as above is that we can update the online version
of the stacks, as we are doing the work, without ever creating holes.
(4) For non-representable morphisms (of Artin stacks), one can define
"unramified = R-unramified" as "locally of finite type and diagonal etale"
or as "locally of finite type and formally unramified" and "etale" as
"locally of finite presentation, flat, and unramified". This looks like a
circular definition but in each step we take the diagonal.
(5) For stacks there is also a notion of "formally Deligne-Mumford". One gets
the very pleasing list:
	DM = formally DM
	R-unramified = formally unramified + loc. of finite type
	etale = formally etale + loc. of finite presentation
Here, the increasing finiteness hypothesis can be explained by the fact the
diagonal of anything is locslly of finite type and the diagonal of locally of
finite type is locally of finite presentation. Also
	DM <=> diagonal unramified and unramified => diagonal etale.
(6) Limits of Schemes: Absloute Noetherian approximation. Add a second proof
following Temkin's proof in [Relative RZ-spaces, section 1.1]. Look also at
David Rydh's paper [Noetherian approximation of algebraic spaces and stacks].
In fact, using this method one gets a short proof of a more general
approximation result (X,S qc and qs schemes, then X -> S can be approximated
as affine and finite presentation and if X -> S is of finite type then we can
do closed immersion and finite presentation. The main point here will be to
excise push-outs from the proof.
(7) Introduce the notion: "pseudo-noetherian" (suggested by Brian Conrad) as a
scheme/stack X which is quasi-compact, quasi-separated and has the property
that any quasi-coherent sheaf is the direct limit of finitely presented
sheaves. David Rydh suggests: require that this holds on X' for any finitely
presented X' -> X as this turns out to be quite useful. Examples of
pseudo-noetherian stacks are noetherian stacks, qcqs algebraic spaces and qcqs
stacks with quasi-finite diagonal.
(8) The approximation results generalizes some of the foundational results,
e.g. in Chevalley's theorem on affineness we can let the finite morphism be
integral (and also let the target be an algebraic space).
(9) More on the relationship between ``universally injective'' and
``radicial''meaning something on field extensions of points. This already does
not make sense for algebraic spaces. A counter-example is
Spec(\overline{Q})/Gal(Q) -> Spec(Q) which is universally injective (there is
only one \overline{Q}-point) but not "radicial". At least universally
injective + quasi-separated => radicial (it is enough that points
are "algebraic", i.e., admit monomorphisms of spectra of fields). In general
we have have:
	universally injective <=> diagonal surjective
	radicial+loc. separated <=> diagonal nil-immersion
Not known whether there exist radicial non-quasi-separated morphisms
(necessarily not locally separated).
(10) Also, for a stack (with algebraic points) one would have to interpret
``radicial'' as "there is exactly one point in every fiber and the residue
field extension is inseparable". The definition of universally injective as
X(K)->S(K) injective is not good for stacks (perhaps ok if we restrict to K
algebraically closed) unless we pass to the associated sheaf. Again we have:
	universally injective <=> diagonal surjective
(11) A related note is that points of any quasi-separated stack (i.e., stack
with quasi-compact and quasi-separated diagonal) are algebraic. This is due to
David Rydh.
(12) Write a chapter on push-outs in the stacks project. This may have been
one of the essential parts of the first conception of EGA V (later moved to
Chapter VI). The algebra/scheme part is worked out in detail by Ferrand
"Conducteur, Descente et Pincement" and it generalizes to algebraic spaces
(the correct level of generality).
(13) In the chapter on Chow homology and Chern classes, maximize the use of
Lemma lemma-secondary-ramification (Tag 02QJ). In particular, prove a version
of Lemma lemma-commutativity-effective-Cartier (Tag 02TF) with supports. This
will lead to a proof of commutativity of intersecting with effective Cartier
divisors, which does not use blowing up Section section-blowing-up-lemmas 
(Tag 02SY) at all.
(14) Rewrite parts of the chapter on Chow homology and Chern classes in order
to have intersections with supports where relevant. There should be
``explicit'' supports and not just of the order of saying that the product
D \cdot \alpha is supported in Supp(D) \cap Supp(\alpha).
(15) Chapter on Etale cohomology: Integrate with the rest of the project. This
means finding references to unproven results, removing any mention of the fpqc
site (although the fpqc topology can be used), etc. Either remove the last few
sections or find a way of clearly indicating that they are `further topics''.
(16) Write sections on Brauer groups: for each case of algebra, schemes,
spaces, stacks.
(17) Related to (16): Start a chapter on noncommutative algebra.
(18) Write up Schessinger's: Functors of Artin rings, in slightly greater
generality.
(19) Artin's theorem on representability.
(20) Artin's theorem that a stack in groupoids with diagonal representable by
algebraic spaces which has a faithfully flat and finitely presented cover by a
scheme is an algebraic stack.
(21) Keel and Mori (some of it is already there).
(22) Etc, etc. See also the chapter Desirables.
(23) Put the following (suggested by David Rydh) in the stacks project:
Using ZMT, one proves the fact that if f:X->Y is quasi-finite and
separated then the subset U of y's such that f restricted to Spec(O_{Y,y})
is finite is open. This is almost a one-liner: pf: The question is local so
we can assume that Y is affine. Take a ZMT factorization X->W->Y. Then
U=Y \ (image of W \ X). Indeed, the closure of a subset commutes with
flat base change. In the same spirit, one easily shows (without ZMT) that
if f:X->Y is quasi-affine then the subset of y's such that f restricted to Spec(O_{Y,y}) is affine is open.



MAINTENANCE
------------

Please contact the maintainer before attempting these:
(0) Split algebra chapter in two (this is hard to do without messing up the
tags system).
(1) Improve Makefile.
(2) Clean up python scripts.
(3) Prettyfy the website.
(4) Improve consistency of notation. Example: ``Known'' categories such as
Sets, Groups, Sheaves, Abelian Sheaves etc are not named in a consistent
manner.
(5) Setup and run a mailing list.
(6) Setup and run a bug system; mainly for feature requests.
(7) Setup and run a sign off system, where collaborators can sign off on
results in the stacks project, i.e., saying ``I declare this is true'', and
where in addition we can put links to similar results in the literature.
(8) Find people willing to mirror the project online, preferably in a very
different geographical location. If you are interested and a major geek please
contact via the email address above. This is related to (1), (2) and (3) above.
(9) Instead of (5), (6), (7) have a system for visitors of the website to leave
comments, which are archived and visible (as the comments left on a blog for
example). Some of these can be labeled as bugs, some as feature requests, some
as declarations of correctness, etc.
